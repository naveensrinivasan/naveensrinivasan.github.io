<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="ie=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=author content="admin">
<meta name=description content="I happened to notice the new I happened to notice the new and it had COM based API for dbgeng. The sample code were in VB Script. I much comfortable writing managed code compared to VB script. So IÂ decided to use COM based API in managed code.
Here are couple of ways to solve certain problems using this
 Parallel GC Roots :- Getting GC Roots from memory dump is the most time consuming because SOS is single threaded.">
<meta name=keywords content>
<meta name=robots content="noodp">
<meta name=theme-color content>
<link rel=canonical href="/?p=1168/">
<title>
Using Managed Code to debug Memory Dumps :: naveen srinivasan â€” Write code.Loves to read
</title>
<link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css>
<link rel=stylesheet href=/main.29c2c8c3fc9cf748254138351f142ac2833b208a68e83aec126edc98b59efef2.css>
<meta itemprop=name content="Using Managed Code to debug Memory Dumps">
<meta itemprop=description content="I happened to notice the new I happened to notice the new and it had COM based API for dbgeng. The sample code were in VB Script. I much comfortable writing managed code compared to VB script. So IÂ decided to use COM based API in managed code.
Here are couple of ways to solve certain problems using this
 Parallel GC Roots :- Getting GC Roots from memory dump is the most time consuming because SOS is single threaded."><meta itemprop=datePublished content="2010-11-11T22:21:02+00:00">
<meta itemprop=dateModified content="2010-11-11T22:21:02+00:00">
<meta itemprop=wordCount content="930"><meta itemprop=image content="/">
<meta itemprop=keywords content>
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="/">
<meta name=twitter:title content="Using Managed Code to debug Memory Dumps">
<meta name=twitter:description content="I happened to notice the new I happened to notice the new and it had COM based API for dbgeng. The sample code were in VB Script. I much comfortable writing managed code compared to VB script. So IÂ decided to use COM based API in managed code.
Here are couple of ways to solve certain problems using this
 Parallel GC Roots :- Getting GC Roots from memory dump is the most time consuming because SOS is single threaded.">
<meta property="article:section" content="Windbg">
<meta property="article:published_time" content="2010-11-11 22:21:02 +0000 UTC">
</head>
<body>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ style=text-decoration:none>
<div class=logo>
<span class=logo__mark>></span>
<span class=logo__text>cd /home</span>
<span class=logo__cursor>
</span>
</div>
</a>
<span class=header__right>
<nav class=menu>
<ul class=menu__inner><li><a href=/posts>posts</a></li><li><a href=/posts>posts</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<main class=post>
<div class=post-info>
</p>
</div>
<article>
<h2 class=post-title><a href="/?p=1168/">Using Managed Code to debug Memory Dumps</a></h2>
<div class=post-content>
<p>I happened to notice the new <a href="http://translate.google.com/translate?hl=en&sl=pt&u=http://blogs.technet.com/b/carnevale/archive/2010/10/04/debugdiag-1-2-beta1.aspx&ei=dwbcTOe4DIGglAfc6uWuCQ&sa=X&oi=translate&ct=result&resnum=5&ved=0CDkQ7gEwBA&prev=/search%3Fq%3Ddebugdiag%2B1.2%26hl%3Den%26client%3Dfirefox-a%26hs%3DNUZ%26rls%3Dorg.mozilla:en-US:official%26prmd%3Div">I happened to notice the new</a> and it had COM based API for dbgeng. The sample code were in VB Script. I much comfortable writing managed code compared to VB script. So IÂ  decided to use COM based API in managed code.</p>
<p>Here are couple of ways to solve certain problems using this</p>
<ol>
<li><strong>Parallel GC Roots</strong> :- Getting GC Roots from memory dump is the most time consuming because SOS is single threaded. I use PFX to do them in parallel.</li>
<li><strong>Reconstructing manged objects</strong> :- Creating an instance of an object by reading data from the memory dump.</li>
</ol>
<p>Need to add reference to the COM Library</p>
<p><a href=http://104.197.135.42/wp-content/uploads/2010/11/dbghost2.png></a></p>
<p>And in VS2010 (.NET 4.0) by defaultÂ  COM Interop types haveÂ  Embed Interop Types turned on. I couldnâ€™t compile the code with this option. I had to turn off Embed Interop types.</p>
<p>Few extension methods for the DbgObj</p>
<p>[sourcecode language=â€csharpâ€]</p>
<p>static class DbgExtensions {</p>
<p>public static DbgObj OpenDump(this DbgControlClass dbg, string dumpPath) {</p>
<p>var path = Environment.GetEnvironmentVariable("_NT_SYMBOL_PATH");</p>
<p>return dbg.OpenDump(dumpPath, path, path, null);</p>
<p>}</p>
<p>public static void LoadSOS(this DbgObj dbg){</p>
<p>// By default it only loads psscor2.dll and It will not work for .NET 4.0</p>
<p>dbg.UnloadExtensions();</p>
<p>// Will load sos based on the framework version</p>
<p>var sos = dbg.GetModuleByModuleName(&ldquo;clr&rdquo;) == null ? &ldquo;.loadby sos mscorwks&rdquo; : &ldquo;.loadby sos clr&rdquo;;</p>
<p>dbg.Execute(sos);</p>
<p>}</p>
<p>public static IEnumerable DumpHeap(this DbgObj dbg, string typeorMT, bool isMT = false) {</p>
<p>var parameter = isMT ? &ldquo;-MT " : &ldquo;-type &ldquo;;</p>
<p>return dbg.Execute("!dumpheap -short " + parameter + typeorMT).Split(new[] { &ldquo;n&rdquo; },</p>
<p>StringSplitOptions.RemoveEmptyEntries);</p>
<p>}</p>
<p>public static string GCRoot(this DbgObj dbg, string address) {</p>
<p>return dbg.Execute("!GcRoot&rdquo; + address);</p>
<p>}</p>
<p>public static double ReadDouble(this DbgObj dbg, string address, string offset) {</p>
<p>return (double)Int32.Parse(</p>
<p>dbg.Execute(string.Format(&ldquo;dd {0}+{1} L1&rdquo;, address, offset)).Replace(&ldquo;n&rdquo;, &ldquo;")</p>
<p>.Split(new[] { " " }, StringSplitOptions.RemoveEmptyEntries)</p>
<p>.ElementAt(1),</p>
<p>NumberStyles.AllowHexSpecifier);</p>
<p>}</p>
<p>public static string ReadString(this DbgObj dbg, string address, string offset) {</p>
<p>// The managed string in x86 starts at 8th offset</p>
<p>return dbg.ReadUnicodeString(ReadDouble(dbg, address, offset) + 8);</p>
<p>}</p>
<p>}</p>
<p>[/sourcecode]</p>
<h3 id=parallel-gc-roots>Parallel GC Roots</h3>
<p>Anybody who is debugged memory dumps for leaks understands the pain of running gcroots within a loop. AFAIK sos is single threaded.Â  I have had customers who had 24 way CPUâ€™s who wanted to use all the CPUâ€™s to debug memory leaks, but it wasnâ€™t possible.</p>
<p>Here is a code that would make parallel gc roots possible</p>
<p>[sourcecode language=â€csharpâ€]</p>
<p>usingÂ System;</p>
<p>usingÂ System.Collections.Generic;</p>
<p>usingÂ System.Linq;</p>
<p>usingÂ System.Globalization;</p>
<p>usingÂ DbgHostLib;</p>
<p>namespaceÂ ConsoleApplication1Â {</p>
<p>classÂ ProgramÂ {</p>
<p>staticÂ voidÂ Main(string[]Â args)Â {</p>
<p>varÂ dumpÂ =Â newÂ DbgControlClass().OpenDump(@&ldquo;C:TestClass.dmp&rdquo;).LoadSOS();</p>
<p>varÂ testInstancesÂ =Â dump.DumpHeap(&ldquo;Test.TestClass&rdquo;);</p>
<p>varÂ rootsÂ =Â testInstances.AsParallel().Select(testclassÂ =></p>
<p>newÂ DbgControlClass().OpenDump(@&ldquo;C:TestClass.dmp&rdquo;).LoadSOS().GCRoot(testclass)).ToList();</p>
<p>Console.Read();</p>
<p>}</p>
<p>}</p>
<p>staticÂ classÂ DbgExtensionsÂ {</p>
<p>publicÂ staticÂ DbgObjÂ OpenDump(thisÂ DbgControlClassÂ dbg,Â stringÂ dumpPath)Â {</p>
<p>varÂ pathÂ =Â Environment.GetEnvironmentVariable("_NT_SYMBOL_PATH&rdquo;);</p>
<p>returnÂ dbg.OpenDump(dumpPath,Â path,Â path,Â null);</p>
<p>}</p>
<p>publicÂ staticÂ DbgObjÂ LoadSOS(thisÂ DbgObjÂ dbg){</p>
<p>//Â ByÂ defaultÂ itÂ loadsÂ psscor2</p>
<p>dbg.UnloadExtensions();</p>
<p>//Â WillÂ loadÂ sosÂ basedÂ onÂ theÂ frameworkÂ version</p>
<p>varÂ sosÂ =Â dbg.GetModuleByModuleName(&ldquo;clr&rdquo;)Â ==Â nullÂ ?Â &ldquo;.loadbyÂ sosÂ mscorwks&rdquo;Â :Â &ldquo;.loadby sosÂ clr&rdquo;;</p>
<p>dbg.Execute(sos);</p>
<p>returnÂ dbg;</p>
<p>}</p>
<p>publicÂ staticÂ IEnumerableÂ DumpHeap(thisÂ DbgObjÂ dbg,Â stringÂ typeorMT,Â boolÂ isMTÂ =Â false)Â {</p>
<p>varÂ parameterÂ =Â isMTÂ ?Â &ldquo;-MTÂ "Â :Â &ldquo;-typeÂ &ldquo;;</p>
<p>returnÂ dbg.Execute("!dumpheapÂ -shortÂ "Â +Â parameterÂ +Â typeorMT).Split(new[]Â {Â &ldquo;n&rdquo;Â },</p>
<p>StringSplitOptions.RemoveEmptyEntries);</p>
<p>}</p>
<p>publicÂ staticÂ stringÂ GCRoot(thisÂ DbgObjÂ dbg,Â stringÂ address)Â {</p>
<p>varÂ sÂ =Â dbg.IsClrExtensionMissing;</p>
<p>returnÂ dbg.Execute("!gcrootÂ "Â +Â address);</p>
<p>}</p>
<p>publicÂ staticÂ doubleÂ ReadDouble(thisÂ DbgObjÂ dbg,Â stringÂ address,Â stringÂ offset)Â {</p>
<p>returnÂ (double)Int32.Parse(</p>
<p>dbg.Execute(string.Format(&ldquo;ddÂ {0}+{1}Â L1&rdquo;,Â address,Â offset)).Replace(&ldquo;n&rdquo;,Â &ldquo;")</p>
<p>.Split(new[]Â {Â "Â "Â },Â StringSplitOptions.RemoveEmptyEntries)</p>
<p>.ElementAt(1),</p>
<p>NumberStyles.AllowHexSpecifier);</p>
<p>}</p>
<p>publicÂ staticÂ stringÂ ReadString(thisÂ DbgObjÂ dbg,Â stringÂ address,Â stringÂ offset)Â {</p>
<p>//Â TheÂ managedÂ stringÂ inÂ x86Â startsÂ at 8thÂ offset</p>
<p>returnÂ dbg.ReadUnicodeString(ReadDouble(dbg,Â address,Â offset)Â + 8);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>[/sourcecode]</p>
<p>The above code loads a memory dump and looks for object type â€œTest.TestClassâ€ and gets its addresses. Then gets GCRoots in parallel using the AsParallel option.</p>
<p><a href=http://104.197.135.42/wp-content/uploads/2010/11/parallelgcroots2.png></a></p>
<h3 id=reconstructing-manged-objects>Reconstructing manged objects</h3>
<p>Using the same API it is pretty easy to create an actual instance of a class from a memory dump.Â  Here is the code for which I dumped the memory.</p>
<p>[sourcecode language=â€csharpâ€]</p>
<p>usingÂ System;</p>
<p>namespaceÂ TestÂ {</p>
<p>classÂ ProgramÂ {</p>
<p>staticÂ Foo[]Â foo=Â newÂ Foo[5];</p>
<p>staticÂ voidÂ Main(string[]Â args)Â {</p>
<p>forÂ (intÂ iÂ =Â 0;Â iÂ &lt;Â 5;Â i++)</p>
<p>foo[i]Â =Â newÂ Foo()Â {Â counterÂ =Â i,Â NameÂ =Â &ldquo;NameÂ "Â +Â i.ToString()Â };</p>
<p>Console.WriteLine(foo);</p>
<p>Console.Read();</p>
<p>}</p>
<p>}</p>
<p>classÂ FooÂ {</p>
<p>publicÂ intÂ counter;</p>
<p>publicÂ stringÂ Name;</p>
<p>publicÂ overrideÂ stringÂ ToString()Â {</p>
<p>returnÂ string.Format(&ldquo;CounterÂ :-Â {0}Â ,Â NameÂ :-Â Â {1}Â &ldquo;,Â counter,Â Name);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>[/sourcecode]</p>
<p>Here is the memory structure of Foo</p>
<blockquote>
<p>0:005> !do 00f1c660</p>
</blockquote>
<blockquote>
<p>Name:Â Â Â Â Â Â Â  Test.Foo</p>
</blockquote>
<blockquote>
<p>MethodTable: 009b38bc</p>
</blockquote>
<blockquote>
<p>EEClass:Â Â Â Â  009b14a4</p>
</blockquote>
<blockquote>
<p>Size:Â Â Â Â Â Â Â  16(0x10) bytes</p>
</blockquote>
<blockquote>
<p>File:Â Â Â Â Â Â Â  C:FoobinDebugFoo.exe</p>
</blockquote>
<blockquote>
<p>Fields:</p>
</blockquote>
<blockquote>
<p>MTÂ Â  Â  Â  Â  Â  Â  Â  Â Â  FieldÂ  Â  Â  Â  Â  OffsetÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  TypeÂ  VTÂ Â Â Â  AttrÂ Â Â  Value Name</p>
</blockquote>
<blockquote>
<p>79ba2978Â  4000002Â Â Â Â Â Â Â  8Â Â Â Â Â Â Â Â  System.Int32Â  1 instanceÂ Â Â Â Â Â Â  2 counter</p>
</blockquote>
<blockquote>
<p>79b9f9acÂ  4000003Â Â Â Â Â Â Â  4Â Â Â Â Â Â Â  System.StringÂ  0 instance 00f1c680 Name</p>
</blockquote>
<p>Notice the variable â€œNameâ€ is in the 4th offset and counter is in the 8th offset. I use these offsets to read its contents from the dump.Here is the code that recreates instances of Foo from the memory dump.</p>
<p>[sourcecode language=â€csharpâ€]</p>
<p>classÂ ProgramÂ {</p>
<p>staticÂ voidÂ Main(string[]Â args)Â {</p>
<p>varÂ dumpÂ =Â newÂ DbgControlClass().OpenDump(@&ldquo;C:tempFoo.dmp&rdquo;).LoadSOS();</p>
<p>varÂ foosÂ =Â dump.DumpHeap(@&ldquo;Test.Foo&rdquo;);</p>
<p>foos.Select(sÂ =>Â newÂ Foo()Â {Â counterÂ =Â (int)dump.ReadDouble(s,Â &ldquo;0x8&rdquo;),Â NameÂ =Â dump.ReadString(s,Â &ldquo;0x4&rdquo;)Â }).</p>
<p>ToList().ForEach(Console.WriteLine);</p>
<p>Console.Read();</p>
<p>}</p>
<p>}</p>
<p>[/sourcecode]</p>
<p>And here is the output from the above code.</p>
<blockquote>
<p>Counter :- 0 , Name :-Â  Name 0</p>
</blockquote>
<blockquote>
<p>Counter :- 1 , Name :-Â  Name 1</p>
</blockquote>
<blockquote>
<p>Counter :- 2 , Name :-Â  Name 2</p>
</blockquote>
<blockquote>
<p>Counter :- 3 , Name :-Â  Name 3</p>
</blockquote>
<blockquote>
<p>Counter :- 4 , Name :-Â  Name 4</p>
</blockquote>
<p>There is lot more to explore than what I have shown above. Happy debuggingÂ  ğŸ™‚</p>
</div>
</article>
<hr>
<div class=post-info>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=/categories/windbg/>Windbg</a></span>
</p>
</div>
</main>
</div>
<footer class=footer>
</footer>
</div>
<script type=text/javascript src=/bundle.min.599099f1f14b78b657d524b28e10e0c5098e7cd46e9c7aed73d577068a276c3ff1bb234cbf29cb313333e83cf411727b43157c91ce5b809e2ffc81664614608e.js integrity="sha512-WZCZ8fFLeLZX1SSyjhDgxQmOfNRunHrtc9V3BoonbD/xuyNMvynLMTMz6Dz0EXJ7QxV8kc5bgJ4v/IFmRhRgjg=="></script>
</body>
</html>