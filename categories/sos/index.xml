<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SOS on naveen srinivasan</title><link>/categories/sos/</link><description>Recent content in SOS on naveen srinivasan</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 06 Dec 2010 00:16:53 +0000</lastBuildDate><atom:link href="/categories/sos/index.xml" rel="self" type="application/rss+xml"/><item><title>Why isn’t the !bpmd in sos / windbg not working?</title><link>/?p=1271/</link><pubDate>Mon, 06 Dec 2010 00:16:53 +0000</pubDate><guid>/?p=1271/</guid><description>&lt;p>I recently noticed another blog &lt;!-- raw HTML omitted -->post &lt;!-- raw HTML omitted -->refer to one of my &lt;!-- raw HTML omitted -->post&lt;!-- raw HTML omitted -->. The issue was, sos wasn’t enabling the break-points on non-jitted functions. The classic example being “Main”.  Thanks to &lt;!-- raw HTML omitted -->Steve &lt;!-- raw HTML omitted --> I have been using sosex and not sos for setting break-points.&lt;/p>
&lt;p>From my previous &lt;!-- raw HTML omitted -->post &lt;!-- raw HTML omitted --> you can understand how CLR is using clrn/CLRNotificationException to notify sos/sosex on JIT. With this information when I looked at the rotor &lt;!-- raw HTML omitted -->code&lt;!-- raw HTML omitted -->, I noticed an interesting member variable “g_dacNotificationFlags”. So I decided to check the value of this variable when using !bpmd from sos and !mbm from sosex.&lt;/p></description></item><item><title>Using sosex within windbg to understand IL and Assembly code</title><link>/?p=1261/</link><pubDate>Tue, 30 Nov 2010 01:33:25 +0000</pubDate><guid>/?p=1261/</guid><description>&lt;p>Sometimes when debugging managed code within the debugger I would like to see the C# code ,the IL translation for the managed code and the Assembly code for the IL. For example I recently learned that callvirt MSIL instruction must do the null-check before invoking method.&lt;/p>
&lt;blockquote>
&lt;p>C:UsersnaveenDocumentsVisual Studio 2010ProjectsConsoleApplication13Program.cs @ 18:&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>00bc26d8 8b4dec          mov     ecx,dword ptr [ebp-14h]&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>00bc26db 3909            cmp     dword ptr [ecx],ecx //NULL Check&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>00bc26dd ff1508a82900    call    dword ptr ds:[29A808h] (System.String.ToLower(), mdToken: 0600031d)&lt;/p></description></item><item><title>Script to !SaveAllModules in .NET 4.0 SOS within Windbg</title><link>/?p=1202/</link><pubDate>Fri, 12 Nov 2010 19:29:06 +0000</pubDate><guid>/?p=1202/</guid><description>&lt;p>The .NET 4.0 sos doesn’t have save all modules (!SaveAllModules) command. It only has !SaveModule. Recently I was debugging a .NET 4.0 process for which I had to save all the modules. Here is a script that does !SaveAllModules.&lt;/p>
&lt;p>[sourcecode]&lt;/p>
&lt;p>!for_each_module .if ($spat (&amp;quot;${@#ImageName}&amp;quot;,&amp;quot;*.exe&amp;quot;)) { !SaveModule ${@#Base} c:temp${@#ModuleName}.exe } .else { !SaveModule ${@#Base} c:temp${@#ModuleName}.dll }&lt;/p>
&lt;p>[/sourcecode]&lt;/p></description></item><item><title>Dumping ASP.NET Session (x86 /x64) within Windbg</title><link>/?p=1071/</link><pubDate>Wed, 27 Oct 2010 01:18:21 +0000</pubDate><guid>/?p=1071/</guid><description>&lt;p>This post is going to be about dumping ASP.NET session objects using Windbg. I had recently answered a stackoverflow question in which someone wanted to dump ASP.NET session objects for 64-bit IIS (x64). I thought why not blog about the same which might be useful to others.  The challenge is to write one script that should work in both x86/x64.  FYI there is a script from &lt;a href="http://blogs.msdn.com/b/tess/archive/2007/09/18/debugging-script-dumping-out-asp-net-session-contents.aspx">Tess&lt;/a> that does dump out the session contents, AFAIK it will not work on x64 and my script iterates through the array using the array length instead of using “.foreach /pS 2 /ps 99” which is somewhat cleaner.&lt;/p></description></item><item><title>Script to load sos within Windbg based on .NET Framework version</title><link>/?p=1032/</link><pubDate>Mon, 26 Jul 2010 04:33:21 +0000</pubDate><guid>/?p=1032/</guid><description>&lt;p>I often debug  .NET Framework v 2.0 / v 4.0 code within windbg. In v 2.0 the main clr dll was called “mscorwks.dll” and in v 4.0 it is called “clr.dll”.  As many of you are aware , to load sos in v 2.0 we would have to enter “.loadby sos mscorwks” and in v 4.0 it would be “.loadby sos clr” . This was a pain for me. Came up with a script to automate loading sos based on clr version&lt;/p></description></item><item><title>Debugging Generic System.Nullable within Windbg</title><link>/?p=947/</link><pubDate>Thu, 08 Jul 2010 03:58:51 +0000</pubDate><guid>/?p=947/</guid><description>&lt;p>In this post I am going to unravel the mystery of debugging the Nullable&lt;!-- raw HTML omitted --> within Windbg in .NET 3.5 and also compare it with .NET 4.0. Here is the sample code and it is compiled in .NET 3.5&lt;/p>
&lt;p>[sourcecode language=”csharp”]&lt;/p>
&lt;p>using System;&lt;/p>
&lt;p>namespace ConsoleApplication&lt;/p>
&lt;p>{&lt;/p>
&lt;p>class Program&lt;/p>
&lt;p>{&lt;/p>
&lt;p>Int32? test;&lt;/p>
&lt;p>int i = 10;&lt;/p>
&lt;p>static void Main(string[] args)&lt;/p>
&lt;p>{&lt;/p>
&lt;p>Nullable&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>Int32? i = 10;&lt;/p>
&lt;p>Object o = 10;&lt;/p></description></item></channel></rss>